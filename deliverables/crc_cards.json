[{"name": "Node","superclasses": "","subclasses": "","type": 1,"responsibilities": ["1. Store all parameters for  a specific process(distribution, ougoing_processes, number_actors, queue_type).","2. Manipulate the queue whenever patient moving into the queue or patient moved into a resource from the queue.","3. Always fill the resources with the next available(right) patient.","4. Send a patient to other processes, whenever the patient finishes this process.","5. Store events from resources onto the global min heap"],"collaborators": ["1. Resource","2. Heap","3. Patient",""]},{"name": "Resource","superclasses": "","subclasses": "","type": 1,"responsibilities": ["1. Contain the current valid(passes the resource rule) patient inside the resource, and the time when the patient finishes the resource.","2. Mark the patient as available/unavailable depending on whether he's inserted in the process or going out of it."],"collaborators": ["1. Node","2. Patient"]},{"name": "Patient","superclasses": "","subclasses": "","type": 1,"responsibilities": ["1. Contain all relevant information about a patient(acuity, needed_processes, predicted_processes).","2. Contain information about patient's availability.","3. Contain a comparator which allows it to be compared in a heap, based on custom rules"],"collaborators": [""]},{"name": "Heap","superclasses": "","subclasses": "","type": 1,"responsibilities": ["1. Store events as a min-heap, with the next event to happen, always on top, based on timestamp","2. Track the entire flow of the simulation, by always extracting the next event to happen.","3. Keep track of the time in the simulation."],"collaborators": ["Event"]},{"name": "Event","superclasses": "","subclasses": "","type": 1,"responsibilities": ["1. Contain information about the patient in the event, and the finish_time of the event.","2. Events have a comparator which allows them to be compared between each other inside a heap"],"collaborators": ["Heap"]}]
