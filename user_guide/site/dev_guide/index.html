<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Developer Guide - ER | Visualizer Guide</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">ER | Visualizer Guide</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../user_guide/">User Guide</a>
                            </li>
                            <li class="active">
                                <a href="./">Developer Guide</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../user_guide/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="disabled">
                                <a rel="prev" >
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#developer-guide-for-er-visualizer">Developer Guide for ER | Visualizer</a></li>
            <li><a href="#setup">Setup</a></li>
            <li><a href="#system-requirements-for-windows">System Requirements for Windows</a></li>
            <li><a href="#layout">Layout</a></li>
            <li><a href="#csv">CSV</a></li>
            <li><a href="#end-to-end-flow-of-data">End-to-End flow of data</a></li>
            <li><a href="#how-tos">How to’s</a></li>
            <li><a href="#faq">FAQ</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="developer-guide-for-er-visualizer">Developer Guide for ER | Visualizer</h1>
<p><!-- Use this for spacing -->
<br> </p>
<h2 id="setup">Setup</h2>
<h2 id="system-requirements-for-windows">System Requirements for Windows</h2>
<ul>
<li>Windows 10 64-bit: Pro, Enterprise, or Education (Build 15063 or later)</li>
<li>Hyper-V and Containers Windows features must be enabled</li>
<li>
<p>This can be done by running the docker application after installing. The user will be prompted and required to restart the computer in order to finish the required setup.</p>
</li>
<li>
<p>The following hardware prerequisites are required to successfully run Client Hyper-V on Windows 10:</p>
</li>
<li>
<p>64 bit processor with <a href="https://en.wikipedia.org/wiki/Second_Level_Address_Translation">Second Level Address Translation (SLAT)</a></p>
</li>
<li>4GB system RAM</li>
<li>BIOS-level hardware virtualization support must be enabled in the BIOS settings (see image).</li>
</ul>
<p><img alt="virtualization example" src="../virtualization-enabled.png" /></p>
<h3 id="installing-and-running-docker-desktop-on-windows">Installing and running Docker Desktop on Windows</h3>
<ul>
<li>
<p>Double-click Docker Desktop Installer.exe to run the installer.</p>
</li>
<li>
<p>If you haven’t already downloaded the installer (Docker Desktop Installer.exe), you can get it from Docker Hub. It typically downloads to your <code>Downloads</code> folder, or you can run it from the recent downloads bar at the bottom of your web browser.</p>
</li>
<li>
<p>Follow the instructions on the installation wizard to accept the license, authorize the installer, and proceed with the install.</p>
</li>
<li>
<p>When prompted, authorize the Docker Desktop Installer with your system password during the install process. Privileged access is needed to install networking components, links to the Docker apps, and manage the Hyper-V VMs.</p>
</li>
<li>
<p>Click Finish on the setup complete dialog and launch the Docker Desktop application.</p>
</li>
</ul>
<h3 id="system-requirements-for-mac-os">System Requirements for Mac OS</h3>
<ul>
<li>
<p>Mac hardware must be a 2010 or newer model, with Intel’s hardware support for memory management unit (MMU) virtualization, including Extended Page Tables (EPT) and Unrestricted Mode. You can check to see if your machine has this support by running the following command in a terminal: sysctl kern.hv_support</p>
</li>
<li>
<p>macOS must be version 10.13 or newer. We recommend upgrading to the latest version of macOS.</p>
</li>
<li>
<p>If you experience any issues after upgrading your macOS to version 10.15, you must install the latest version of Docker Desktop to be compatible with this version of macOS.</p>
</li>
</ul>
<p>Note: Docker supports Docker Desktop on the most recent versions of macOS. That is, the current release of macOS and the previous two releases. As new major versions of macOS are made generally available, Docker will stop supporting the oldest version and support the newest version of macOS (in addition to the previous two releases).</p>
<ul>
<li>
<p>At least 4 GB of RAM.</p>
</li>
<li>
<p>VirtualBox prior to version 4.3.30 must not be installed as it is not compatible with Docker Desktop.</p>
</li>
</ul>
<h3 id="installing-and-running-docker-desktop-on-mac">Installing and running Docker Desktop on Mac</h3>
<ul>
<li>
<p>Double-click Docker.dmg to open the installer, then drag the Docker icon to the Applications folder.</p>
</li>
<li>
<p>Install Docker app</p>
</li>
<li>
<p>Double-click Docker.app in the Applications folder to start Docker. (In the example below, the Applications folder is in “grid” view mode.)</p>
</li>
</ul>
<p>You are prompted to authorize Docker.app with your system password after you launch it. Privileged access is needed to install networking components and links to the Docker apps.</p>
<p>The Docker menu in the top status bar indicates that Docker Desktop is running, and accessible from a terminal.</p>
<p>If you just installed the app, you also get a message with suggested next steps and a link to the documentation. Click the Docker menu (whale
 menu) in the status bar to dismiss this pop-up notification.</p>
<ul>
<li>
<p>Click the Docker menu (whale menu) to see Preferences and other options.</p>
</li>
<li>
<p>Select About Docker to verify that you have the latest version.</p>
</li>
</ul>
<h3 id="instructions">Instructions</h3>
<p>Setup: Download the docker installer <a href="https://www.docker.com/products/docker-desktop">here</a> and follow the docker setup instructions above. The website directs you to the correct version base on your OS
Then, start the application by double clicking the docker icon in your Applications folder.</p>
<h3 id="running-the-application">Running the Application:</h3>
<p>Run <code>docker-compose down</code> - in case you already have docker and have something running on the same port
Then run <code>./run_dev.sh build</code> - to build the image/run the application
  - The client and server services will be instantiated with the ports indicated in the .env file.
  - The client can be accessed at http://localhost:5000 by default.
In the event that you have already built the image and want to run
it again you can simply run <code>./run_dev.sh`</code>
Note: you do not have to worry about any other setup either than ensuring you have docker on your device.</p>
<p>In the event that you have issues due to conflicting ports, you can change the values of the following port variables in the env file (located at the root of the repository).</p>
<pre><code>APP_SERVER_PORT = {Backend port number - default 8000}
REACT_APP_PORT = {Frontend port number - default 5000}
DEV_ENV = development
WEB_SOCKET_PORT = {WSS port number - default 8765}
</code></pre>

<h2 id="layout">Layout</h2>
<pre><code>backend/     
    app/
        models/
            rules/
            ...
    tests/
        models/
        unit_tests/
Developer Guide/
    docs/
frontend/
    node_modules/
    public/
    src/
        components/
            ...
        models/
            ...
        redux/
            ...
User Guide/
    docs/
</code></pre>
<ul>
<li>
<p>Frontend 
    &gt; <code>Main.js</code> acts as the manager for the frontend and intializes the websocket on the frontend and recieves events from the frontend which are then sent to redux
    functions which update the simulation
    &gt; Redux manages the simulation state, specifically the node data, and which 
    sidebars are shown</p>
</li>
<li>
<p>Backend 
    &gt; <code>run.py</code> in the app folder manages all data, from creating the nodes to 
    sending events</p>
</li>
<li>Entry point of app
    &gt; <code>main.py</code> in the backend handles requests to the backend. Currently there 
    2 routes one takes in the csv uploaded from the frontend and parses it to be
    used by the simulation, the other starts the simulation when it recieves a post
    request with the canvas layout </li>
<li>Websockets
    &gt; <code>connect.py</code> has our websocket class for the backend which sends data to the frontend</li>
</ul>
<h2 id="csv">CSV</h2>
<ol>
<li>Each row represents 1 patient, and each column its attributes</li>
<li>Must have columns with following names(outlined in global_strings.py):</li>
<li>time: Indicates the start_time of the patient, i.e when the patient comes into the hospital.</li>
<li>id: id of the simulation object(patient in this case)</li>
<li>acuity: 1-5</li>
<li>For predicted columns, values must be: {1 for True, 0 for False}</li>
<li>For frequency columns, values must be: &gt;= 0</li>
</ol>
<h2 id="end-to-end-flow-of-data">End-to-End flow of data</h2>
<h3 id="runpy">run.py</h3>
<ol>
<li>The entry point starts at the main() function which is called from the REST API /start. The main function then initializes all the required global variables. Then loads the input canvas initializes a thread to start the simulation (SimulationWorker class) and another to start the websocket (by initializing WebsocketServer from connect.py).</li>
<li>The SimulationWorker iterates through the input canvas to instantiate all the nodes on the canvas with their parameters and stores all nodes in a dictionary for future use.</li>
<li>A node may contain node or resource rules which are also initialized at this point.</li>
<li>Once the canvas is loaded, the simulation reads the input csv file and adds patients into a preemptive node (patient loader), which only serves the purpose of adding patients into the starting point of the workflow (the reception queue
at the right time (as dictated in the csv input).</li>
<li>Changes to the simulation (such as patients getting treated by a resource) are represented by Event objects. Event objects have a time attribute which dictate
when they occur, and are stored in an event heap. </li>
<li>Events are handled one at a time in process_heap(), and a global time variable will be updated to the time of the event popped from the event heap.</li>
<li>After an event is handled, the Statistics object is updated.</li>
<li>When communicating with the frontend, there will be a list of all the processed events. Instead of sending the entire list at once, only a user-specified time interval of events will be 
sent. The user can also specify how often the backend sends changes to the frontend. Since communication is independent of the simulation, changing these parameters will not affect the 
simulation in the backend.</li>
<li>Once the simulation finishes, the contents of the final Statistics object will be sent to the frontend and the backend will terminate.</li>
</ol>
<h4 id="heap">Heap</h4>
<ul>
<li>Simulation is based on a Heap, which contains Event objects. The priority inside the heap is the time the patient will
finish the resource. The heap only contains events which are about a patient finishing a resource, and uses this to track the movement
of time in a chronological fashion. </li>
</ul>
<h3 id="websocket">Websocket</h3>
<ul>
<li>The WebsocketServer class is located at connect.py and sends events to the frontend.</li>
<li>WebsockerServer has the following attributes:<ul>
<li>host: The host name the server is being served on (in our use case its localhost)</li>
<li>port: The port to send events on.</li>
<li>producerFunc: The function to generate events to send to the frontend (send_e from run.py).</li>
<li>server: The event loop in the websocket thread.</li>
<li>wserver: The websocket server.</li>
<li>process: The function to process events in the event heap (process_heap)</li>
<li>stats: The function to get simulation statistics.</li>
<li>sent_stats: Checks whether stats have been sent.</li>
<li>packet_rate: The frequency to send events.
<p>&nbsp;</p></li>
</ul>
</li>
<li>The start method is called by run.py which starts the websocket thread that runs until the simulation ends.</li>
<li>__producer_handler is then constantly called which is in charge of running the process_heap method from run.py. This allows the simulation to continue running by continuously processing generated events.</li>
<li>The rate in which __producer_handler is called is changed by the input packet rate, passed in from the frontend. Thus, this then allows the rate of the simulation to be changed.</li>
<li>Based of process_heap, __producer_handler will either continue sending generated events, or generate the statistics of the simulation then send them and close its sockets.</li>
<li>The class also formats the generated statistics to be in a CSV format to be send to the frontend.</li>
<li>To generate the CSV file, since process names are column headers, it is more readable if the column headers are sorted in order of traversal through the canvas. nodes_in_bfs_order() returns a sorted list of process names.</li>
</ul>
<hr />
<h3 id="models">Models</h3>
<h4 id="nodes">Nodes</h4>
<ul>
<li>Nodes are the fundamental building blocks of the simultation. They represent a process such as:
<em>reception</em>, <em>triage</em>, <em>doctor's office</em>, etc. </li>
<li><strong>Attributes</strong>:</li>
<li>id's which are used to uniquely identify a node. <code>Note</code>: <em>Id 0 is reserved for Reception</em>, and <em>Id -1 is reserved for the patient_loader(see details above in run.py)</em></li>
<li>Queue_type: There are 3 types of queues: Stacks, Queue, and Priority Heap. The user specifies on the front-end what kind of queue he wants to use. <em>See Queues</em> for more details</li>
<li>priority_function: priority_function is set only if the user chose a priority queue on the frontend, otherwise it's none.</li>
<li>num_actors defines the number of resources/actors inside the resource. A resource will have a minimum of 1 resource, which means there is only 1 employee/doctor/member of staff/etc operating in there. </li>
<li>resource_dict: a dictionary which contains the resources as their values(built based on the number of actors), and the ids of resources as keys.</li>
<li>distribution_name and distribution_params: the parameters of the distribution that will describe how much time a patient spends inside a resource for this particular node.</li>
<li>output_process_ids: the nodes that the patient will go to once he finishes this current node.</li>
<li>static dictionary of nodes <code>node_dict</code> which contains all of the nodes with 
  their ids as values.</li>
<li>node_rules: all of the rules for a specific node.</li>
<li><strong>Important Methods</strong>:</li>
<li>Technically, nodes are the ones that run the simulation. They move the patients from one to another, ass the patients into the right resource, into the right queues.</li>
<li><code>handle_finished_patient(resource_id)</code>:<ul>
<li>Called from run.py whenever an event is popped off the heap, which 
signifies that it finished. At that point, handle_finished_patient() is called which is responsible for 2 things: insert patients into the next nodes
that the patient needs to go to, fill the resource that the patient just finished with an appropriate patient from the queue of the node.</li>
<li>Because the patient is still in some queues, the node attempts to insert him into resources for the nodes where the patient is still queued(patient is still in queue to get a CT-scan so handle_finished_patient() will check to see if any CT scans have been freed), as well as into the outgoing nodes from this current node(i.e this node is triage and has an outgoint edge: Triage-&gt;Doctor).</li>
<li>An event is created and sent to GlobalEvents, which is read by run.py to send to the frontend. The event will be a patient leaving a resource.</li>
</ul>
</li>
<li><code>put_patient_in_node(patient)</code>:<ul>
<li>Called whenever a patient is inserted into a node X.</li>
<li>First check if patient passes all of the rules which make him eligible to be inside of node X(e.g: have acuity &gt; 5, etc).</li>
<li>If passes all rules, then try to insert him into a resource. If that fails,
place him inside the queue.</li>
</ul>
</li>
<li><code>put_inside_queue(patient)</code>:<ul>
<li>place patient inside of ahe queue, and put that into patient's current record.</li>
<li>An event is created and sent to GlobalEvents, which is read by run.py to send to the frontend. The event will be a patient joining a queue.</li>
</ul>
</li>
<li><code>fill_spot(patient)</code>:<ul>
<li>Patient is passed and attempts to enter any available resources. If either
the patient becomes unavailable, or all resources are busy, fill_spot returns False.</li>
<li>If The patient is available, and a resource is free, and patient passes the test for it, <code>insert_patient_to_resource_and_heap</code> gets called.</li>
</ul>
</li>
<li><code>insert_patient_to_resource_and_heap(patient, resource)</code>:<ul>
<li>Patient is inserted into the resource,his patient_record gets updated, and he is set as unavailable.</li>
<li><strong>An event is created and inserted onto the heap with the finish time of when the patient will finish the given resource.</strong> So whenever a patient is inserted inside a resource, the event gets registered on the heap.</li>
<li>An event is created and sent to GlobalEvents, which is read by run.py to send to the frontend. The event will be a patient joining a resource.</li>
</ul>
</li>
<li><code>fill_spot_for_resource</code>:<ul>
<li>Called when a patient finishes a resource, so the resource becomes available and can take another patient. Resources will attempt to take another patient from the queue of the node. If a patient is available and passes its rules, he is inserted into the resource by again calling <code>insert_patient_to_resource_and_heap(patient, resource)</code>. He is removed from the queue, and his patient record gets updated.</li>
</ul>
</li>
</ul>
<h4 id="resource">Resource</h4>
<ul>
<li>
<p>A resource is the smallest functioning element inside the simulation. A resource always exists only inside the nodes and represents 1 independent unit which takes simulation objects(patients) for a duration of time. <strong>Let's consider an example: if we have an X-ray Node, with 3 num actors, a resource will be an X-ray machine, and the node has 3 x-ray machines.</strong></p>
</li>
<li>
<p><strong>Attributes</strong></p>
</li>
<li>Id: id of the resource inside of the node, since there can be multiple. They
  are automatically generated when a node is initialized based on number of actors.</li>
<li>curr_patient: if the curr_patient is set to None, that means that the resource is currently available. Otherwise, the attribute will be set to the id of the
  simulation object/ curr_patient id that the resource is occupied with</li>
<li>finish_time: if curr_patient is not None, then finish_time will indicate when
  the resource will complete its work with the patient, in this case it will indicate when a patient finishes the X-ray).</li>
<li>duration: duration of the current, in this case how long this curent X-ray lasts. </li>
<li>resource_rules: Resources can have rules applied to them. In order for a patient to be inserted to a
  specific X-ray machine, it first needs to pass the rule for the X-ray machine. An example of a rule is:
  you need above a specific acuity to use this X-ray. See <strong>Rules</strong> for more.</li>
<li><strong>Important Methods</strong>:</li>
<li>insert_patient(): Inserts a patient into the resource. Sets the attributes(patient, node_id, finish_time, duration). Sets the patient as unavailable.</li>
<li>clear_patient(): i.e patient finishes the resource so clear him out of it. Set the patient as available, so he can join other resources, and set curr_patient and finish_time to None.</li>
</ul>
<h4 id="patient">Patient</h4>
<ul>
<li>A Patient is the simulation object that moves around. Patients are declared in the CSV file, 1 patient per row. They don't have to be patients. You can include any object in the CSV that you want to run the simulation on, and you can include any properties there.</li>
<li>Attributes:</li>
<li>properties: This is the dictionary of all attributes for the patient from the CSV, where the key is the name of the column,
  and the value is the value in the column.</li>
<li>is_available: False if patient is inside a resource. Patient can only be inside 1 resource at a time, and this is used to make sure this is satisfied.</li>
<li>patient_record: a record for the patient of all the nodes he has visited already, the current node he is in(otherwise None), and all the queues he is in.</li>
<li>Important Methods:</li>
<li>set_available(). This is called from inside resource.clear_patient(), so whenever a patient finishes a resource, he's automatically set to available.<ul>
<li>sets is_available property</li>
<li>sets curr_node in patient record to None</li>
<li>clears the queues_since_last_finished_process attribute, since that list contains all of the queues the patient has been added to since the last
node he has finished, and since a patient is set available when he finished
a resource, that means he just finished it, so we need to reset that list</li>
</ul>
</li>
<li>set_unavailable(): This is called from inside resource.insert_patient().<ul>
<li>sets the is_available attribute to False</li>
<li>sets the current node inside the patient record</li>
</ul>
</li>
</ul>
<h4 id="objectrecord">ObjectRecord</h4>
<ul>
<li>An objectRecord is a record for a patient that contains infromation about all the nodes a patient has visited already, the current node he is in(otherwise None), and all the queues he is in.</li>
<li>Attributes:</li>
<li>object_id: id of the patient</li>
<li>visited: represents a list of <code>node_acces_info</code> objects`, i.e all the nodes the patient has visited, in the corred order with extra information.<ul>
<li>Properties of a node_access_info:
<code>self.process_id = curr_process_id
self.resource_id = curr_resource_id
self.resource_start_time = start_time
self.resource_end_time = end_time</code></li>
</ul>
</li>
<li>curr_node: a <code>node_access_info</code> object` for the current_node the patient is in.</li>
<li>Queues:<ul>
<li>queues_since_last_finished_process:  list of the queues a patient is added to in a current round, i.e since patient finished his last node.</li>
<li>old_active_queues: queues the patient is still in, that are not part of the current round.</li>
</ul>
</li>
</ul>
<h4 id="queues">Queues</h4>
<ul>
<li>3 types: Stack, Heap, and Queue.</li>
<li>All classes have an iterator defined, so that the user can iterate through the objects inside of the queue in the right order.</li>
<li>Important Methods:</li>
<li>put()</li>
<li>get()</li>
<li>
<p>remove()</p>
</li>
<li>
<p>The Heap class has a few additional attributes:</p>
</li>
</ul>
<pre><code class="python">    def __init__(self, priority_type, priority_function, l=[]):
        # convert input list into heap
        l = l[:]
        heapq.heapify(l)
        # assign q into heap
        self.q = l
        # assign priority type
        self.p_type = priority_type
        # assign priority function
        self.p_func = priority_function
        # if priority is custom then parse the input code
        if self.p_type == &quot;custom&quot;:
            self._parse_p_func()
</code></pre>

<ul>
<li>The heap gets the priority type and function from the frontend. If the type is acuity or arrival time then the min heap uses the respective values whenever a patient is added in to sort it.</li>
<li>A patient is added as a tuple into the heap in the following format: (priority value, patient element). Python's heapq library automatically sorts the elements by the first index of a tuple.</li>
<li>Users also have the option to define their own function to generate a priority value per patient. So when the type is custom, a priority value is calculated using the input code from the frontend.</li>
</ul>
<h4 id="events">Events</h4>
<ul>
<li>Event objects on the heap contain the patient, the time he will finish a resource, and the node id and resource id.</li>
<li>Attributes:</li>
</ul>
<pre><code class="python">    self.patient_id = patient_id
    self.event_time = event_time # when the event finishes
    self.node_id = node_id
    self.node_resource_id = node_resource_id
    self.moved_to = None # where the event moved to
    self.in_queue = True # which queues it's in
    self.finished = False
</code></pre>

<h4 id="rules">Rules</h4>
<ul>
<li>Rules are restrictions that a patient must adhere to to either be allowed inside a node, or a resource or both. Values for
them are specified inside the CSV, where each patient can have different values for different rules, i.e: if it's a FrequencyRule[see blow], patient A can visit node 3, 4 times, whilst patient B can only visit 1 time.</li>
<li>There are two categories of rules: NodeRules and ResourceRules.<ul>
<li>NodeRules apply to a node object, and include FrequencyRules and PredictionRules.
These are rules that a patient must satisfy in order to be allowed inside a node
(where he can occupy a queue or a resource). If patient fails any of the rules
then the patient is not admitted into the process.</li>
<li>A node with a FrequencyRule can be visited multiple times by a patient
  on a case to case basis (i.e. each patient will visit a different number of times). 
  FrequencyRule objects keep track of which column in the patients csv file 
  the program has to read from in order to see how many times a patient has to reenter a node.</li>
<li>A node with a PredictionRule has a conditional patient admittance behaviour. For example, a
  patient can be predicted to require a scan, so they can be preemptively added to the waiting queue
  before being seen by the doctor.</li>
<li>ResourceRules: A resource may have a rule which will be used to decide whether the patient is allowed in or not, i.e
can patient P go to doctor A, can patient P go to X-ray 2? If a node allows him in, but a resource rejects the patient, the patient will instead be inserted in another resource, one for which he passes all of the rules.</li>
<li>FirstComeFirstServeRule: This rule is used in conjuction with a PredictionRule on the Node, for cases when a patient will
  visit a node N multiple times. When this rule is used, if a patient goes to resource C, any time in the future when he needs to
  visit the same node N, he is only allowed inside resource C. This is particularly useful for cases like the Most Responsible Doctor, where if patient is first seen by doctor C, he will only go back to doctor C, instead of other doctors, as that doctor is responsible for him. </li>
</ul>
</li>
<li>Rules are created in the rule_creator_factory, that is called in create_queues, located in run.py. </li>
<li>RuleVerifier: has a method <code>pass_rules</code> where you pass a patient, and a set of rules, and return True only if the 
patient passes all of the rules for it. Used inside a Node to check if a patient passes all of the rules for the Node,
and to also check if a patient passes all of the rules for a resource.</li>
<li>If you want to create a rule, define it in the rules directory in modules, and inside rule_creator_factory.py</li>
</ul>
<h4 id="statistics">Statistics</h4>
<ul>
<li>The Statistic class handles recording information throughout the simulation to generate statistics at the end.</li>
<li>Attributes:</li>
</ul>
<pre><code class="python"># Patient stats
        # structure: {'Patient_1': {'reception': 1 ...} ...}
        self.p_process_times = {}
        # structure: {'Patient_1': {'reception': 1 ...} ...}
        self.p_wait_times = {}
        # Doctor stats
        # structure: {'Doctor_1': 1, ...}
        self.d_seen = {}
        # structure: {'Doctor_1': {'Patient_1': [1], ...} ...}
        self.d_length = {}
        # Hospital stats
        self.sum_ratio_wait = 0.0
        self.sum_ratio_journey = 0.0
        self.start_time = float(&quot;INF&quot;)
        self.end_time = float(&quot;-INF&quot;`)
</code></pre>

<ul>
<li>Functions add_process_time, add_wait_time, increment_doc_seen, add_doc_patient_time is used to throughout the simulation to record information. The functions are all called at process_heap() in run.py.</li>
<li>The function calculate_stats is used to aggregate all the statistics at the end.</li>
</ul>
<h4 id="rules_1">Rules</h4>
<h4 id="frontend-code-flow">Frontend code flow</h4>
<ul>
<li>Graph rendering<ul>
<li>The global redux store contains a property in its' state called <code>nodes</code>. Before the nodes
are sent as props to <code>Graph.jsx</code> to be rendered, the <code>update_graph()</code> method in <code>Main.js</code> transforms
them into two objects that <code>Graph.jsx</code> requires to render a graph: a node object with the data for each node and a links object with the data
for links between nodes. </li>
<li>Once the nodes and links are given as props to<code>Graph.jsx</code> in <code>Main.js</code>. <code>Graph.jsx</code> will take in the node props and link props
and give them to <code>renderGraph()</code> in <code>graph.renderer.js</code>. The <code>renderGraph()</code> method then 
further makes sub calls to <code>_renderNodes()</code> and <code>_renderLinks()</code> in <code>graph.renderer.js</code>. <ul>
<li><code>_renderNodes()</code> takes in the nodes passed in as props to <code>Graph.jsx</code> and creates an array
of <code>Node.jsx</code> objects each with their own position, and information to be displayed on the canvas.</li>
<li><code>_renderLinks</code> takes in the links passed in as props to <code>Graph.jsx</code> and creates an array
of <code>Links.jsx</code> objects each witht their own start, end positions and styles that are displayed on the 
canvas.</li>
</ul>
</li>
<li><code>renderGraph()</code> takes the list of <code>Node.jsx</code> objects and <code>Links.jsx</code> objects and returns them 
to be rendered by react.</li>
<li>If you want to change the style of a node, or what is displayed, go to <code>Node.jsx</code>. The information
for a node that was in the <code>nodes</code> array in the global redux state can be accessed through <code>this.props</code> in
<code>Node.jsx</code>. </li>
<li>If you want to change the style of a link, go to <code>Link.jsx</code>.</li>
<li>If you want to change the start and end positions for a link, go to: <code>buildLinkPathDefinition()</code> in
<code>link.helper.js</code>. </li>
</ul>
</li>
</ul>
<h2 id="how-tos">How to’s</h2>
<h3 id="backend">Backend</h3>
<ul>
<li>Add a new field to csv and have it used by priority queue<ul>
<li>A: The code has been made easily extensible and hence when a field is added to the patient it is parsed by our code and added to the patient object's dictionary.</li>
</ul>
</li>
<li>Add more stats <ul>
<li>A: In <code>statistic.py</code> you have the ability to add more stats
based on the info of the application</li>
</ul>
</li>
<li>Add a new route for the app<ul>
<li>In <code>main.py</code> define a new route following the classical flask definition methods</li>
</ul>
</li>
<li>Add more rule types<ul>
<li>To add another rule option to the current list of resource or node rules, add another case to the 
_create_rules function in the NodeRuleCreator or ResourceRuleCreator class. These classes can be found in rule_creator_factory.py.</li>
<li>To add a rule type that does not apply to resources or nodes, add another case to the create_queues function in
the RuleCreatorFactory class. The canvas JSON structure and create_queues function in run.py will also have to be modified to call create_rules
using the new RuleCreator class.</li>
</ul>
</li>
</ul>
<h3 id="frontend">Frontend</h3>
<ul>
<li>Add a button <ul>
<li>A: In  <code>Navbar.js</code>  define a button using standard convention in the render method, you can create styling for it in <code>Navbar.css</code> . 
To update the state of the application you have to create your own action in redux as well a method in <code>reducers.js</code> to execute your update.</li>
</ul>
</li>
<li>Change the graph<ul>
<li>In the folder react-d3-graph you have access to the node structure and change the rendering and layout/styling of nodes.</li>
<li>In <code>Main.js</code> there is a graph config object and also a function to map redux's graph model to react-d3-graph's graph model.</li>
<li>For more detailed information on the original package, visit https://goodguydaniel.com/react-d3-graph/docs/index.html </li>
</ul>
</li>
<li>Change styling of components <ul>
<li>Every react component has its own css file. To change the graph, see the previous subsection.</li>
</ul>
</li>
<li>Change styling for core components (not sure what to call it )</li>
</ul>
<h3 id="devops">Devops</h3>
<ul>
<li>Change ports<ul>
<li>A; in the root directory of the app there is a <code>.env</code> which you can modify to update the ports </li>
</ul>
</li>
<li>Change build settings <ul>
<li>A: Depending on if your using production or develop there are two serpate docker compose files in the root level of the app, which can be edited, further there are individual docker files for the frontend and backend which can be further changed </li>
</ul>
</li>
<li>Add a new requirement in the backed<ul>
<li>A: Simply add the package you want to the requirements.txt file in the backend folder, and then run either <code>./run_dev.sh</code> or <code>./run_prod.sh</code> depending on your preference to rebuild with the new requirement</li>
</ul>
</li>
<li>Script Usage 
    A: To run in development, run <code>./run_dev.sh</code>. To run in production, run <code>./run_prod.sh</code>. You can add the build command to either script (i.e <code>./run_dev.sh build</code>) to force docker to rebuild the image as caching is an issue sometimes. Both scripts then transfer all variables in .env to the frontend and backend folders. The frontend variables can't be directly copied as React is only able to automatically read environment variables beginning with REACT_APP_. Thus, all variables have REACT_APP_ appended as a prefix. The script then stops existing containers and finally starts new ones (it may rebuild the image if you add the build command).</li>
</ul>
<h2 id="faq">FAQ</h2>
<ul>
<li>Q: When I add an npm package, I get an error saying that it can't be resolved even though I ran <code>npm install</code><ul>
<li>A: stop the docker image you currenly have running by pressing command + c in your terminal 
Then run <code>./run_dev.sh build</code></li>
</ul>
</li>
<li>Q: Whenver docker runs, it takes up a lot of space on my computer, is there a way I can remove all images.<ul>
<li>A: run <code>docker system prune</code> to remove all docker images</li>
</ul>
</li>
<li>Q: How does docker work, is this is sometype of witchcraft?<ul>
<li>A: Yes.... </li>
</ul>
</li>
<li>Q: Why does take so long to run <ul>
<li>A: The docker image is building both the frontend and backend 
requirements hence it had to install several packages hence it takes a larger amount of time. If you already built the image ie ran <code>./run_dev.sh` build</code>then run  <code>./run_dev.sh`</code> </li>
</ul>
</li>
<li>Q: Why must there be at least 1 node at all times?<ul>
<li>A: This is a limitation of react-d3-graph.</li>
</ul>
</li>
<li>Q: Should I use the index or the id to identify a node?<ul>
<li>A: Use the id, indices are subject to change on deleting/adding nodes.</li>
</ul>
</li>
<li>Q: Why can't I access the variable I added to the .env file on the frontend?<ul>
<li>A: Make sure you're calling it with REACT_APP_ appended as a prefix. So if you called it <code>test_var</code>, make sure to call <code>REACT_APP_test_var</code>.</li>
</ul>
</li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
